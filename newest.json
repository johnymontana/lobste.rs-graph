[{"short_id":"wswo1k","short_id_url":"https://lobste.rs/s/wswo1k","created_at":"2023-03-11T21:58:40.000-06:00","title":"Macige - CI workflow generator for mobile app development","url":"https://github.com/tramlinehq/macige","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/wswo1k/macige_ci_workflow_generator_for_mobile","submitter_user":{"username":"pratul","created_at":"2018-11-29T01:09:02.000-06:00","is_admin":false,"about":"I work on [tramline.app](https://tramline.app). \r\n","is_moderator":false,"karma":13,"avatar_url":"/avatars/pratul-100.png","invited_by_user":"abhin4v"},"tags":["android","devops","ios"]},{"short_id":"kthfvu","short_id_url":"https://lobste.rs/s/kthfvu","created_at":"2023-03-11T21:57:40.000-06:00","title":"A classification of S-boxes generated by Orthogonal Cellular Automata","url":"https://arxiv.org/pdf/2303.05228.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eMost of the approaches published in the literature to construct S-boxes via Cellular Automata (CA) work by either iterating a finite CA for several time steps, or by a one-shot application of the global rule. The main characteristic that brings together these works is that they employ a single CA rule to define the vectorial Boolean function of the S-box. In this work, we explore a different direction for the design of S-boxes that leverages on Orthogonal CA (OCA), i.e. pairs of CA rules giving rise to orthogonal Latin squares. The motivation stands on the facts that an OCA pair already defines a bijective transformation, and moreover the orthogonality property of the resulting Latin squares ensures a minimum amount of diffusion. We exhaustively enumerate all S-boxes generated by OCA pairs of diameter $4 \\le d \\le 6$, and measure their nonlinearity. Interestingly, we observe that for $d=4$ and $d=5$ all S-boxes are linear, despite the underlying CA local rules being nonlinear. The smallest nonlinear S-boxes emerges for $d=6$, but their nonlinearity is still too low to be used in practice. Nonetheless, we unearth an interesting structure of linear OCA S-boxes, proving that their Linear Components Space (LCS) is itself the image of a linear CA, or equivalently a polynomial code. We finally classify all linear OCA S-boxes in terms of their generator polynomials.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.05228\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"Most of the approaches published in the literature to construct S-boxes via Cellular Automata (CA) work by either iterating a finite CA for several time steps, or by a one-shot application of the global rule. The main characteristic that brings together these works is that they employ a single CA rule to define the vectorial Boolean function of the S-box. In this work, we explore a different direction for the design of S-boxes that leverages on Orthogonal CA (OCA), i.e. pairs of CA rules giving rise to orthogonal Latin squares. The motivation stands on the facts that an OCA pair already defines a bijective transformation, and moreover the orthogonality property of the resulting Latin squares ensures a minimum amount of diffusion. We exhaustively enumerate all S-boxes generated by OCA pairs of diameter $4 \\le d \\le 6$, and measure their nonlinearity. Interestingly, we observe that for $d=4$ and $d=5$ all S-boxes are linear, despite the underlying CA local rules being nonlinear. The smallest nonlinear S-boxes emerges for $d=6$, but their nonlinearity is still too low to be used in practice. Nonetheless, we unearth an interesting structure of linear OCA S-boxes, proving that their Linear Components Space (LCS) is itself the image of a linear CA, or equivalently a polynomial code. We finally classify all linear OCA S-boxes in terms of their generator polynomials. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.05228)","comments_url":"https://lobste.rs/s/kthfvu/classification_s_boxes_generated_by","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"iqhb05","short_id_url":"https://lobste.rs/s/iqhb05","created_at":"2023-03-11T21:56:47.000-06:00","title":"Mark My Words: Dangers of Watermarked Images in ImageNet","url":"https://arxiv.org/pdf/2303.05498.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThe utilization of pre-trained networks, especially those trained on ImageNet, has become a common practice in Computer Vision. However, prior research has indicated that a significant number of images in the ImageNet dataset contain watermarks, making pre-trained networks susceptible to learning artifacts such as watermark patterns within their latent spaces. In this paper, we aim to assess the extent to which popular pre-trained architectures display such behavior and to determine which classes are most affected. Additionally, we examine the impact of watermarks on the extracted features. Contrary to the popular belief that the Chinese logographic watermarks impact the “carton” class only, our analysis reveals that a variety of ImageNet classes, such as “monitor”, “broom”, “apron” and “safe” rely on spurious correlations. Finally, we propose a simple approach to mitigate this issue in fine-tuned networks by ignoring the encodings from the feature-extractor layer of ImageNet pre-trained networks that are most susceptible to watermark imprints.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.05498\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"The utilization of pre-trained networks, especially those trained on ImageNet, has become a common practice in Computer Vision. However, prior research has indicated that a significant number of images in the ImageNet dataset contain watermarks, making pre-trained networks susceptible to learning artifacts such as watermark patterns within their latent spaces. In this paper, we aim to assess the extent to which popular pre-trained architectures display such behavior and to determine which classes are most affected. Additionally, we examine the impact of watermarks on the extracted features. Contrary to the popular belief that the Chinese logographic watermarks impact the \"carton\" class only, our analysis reveals that a variety of ImageNet classes, such as \"monitor\", \"broom\", \"apron\" and \"safe\" rely on spurious correlations. Finally, we propose a simple approach to mitigate this issue in fine-tuned networks by ignoring the encodings from the feature-extractor layer of ImageNet pre-trained networks that are most susceptible to watermark imprints. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.05498)","comments_url":"https://lobste.rs/s/iqhb05/mark_my_words_dangers_watermarked_images","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["ai","pdf"]},{"short_id":"0grcqx","short_id_url":"https://lobste.rs/s/0grcqx","created_at":"2023-03-11T21:55:00.000-06:00","title":"SALSA PICANTE: a machine learning attack on LWE with binary secrets","url":"https://eprint.iacr.org/2023/340.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThe Learning With Errors (LWE) problem is one of the major hard problems in post-quantum cryptography. For example, 1) the only Key Exchange Mechanism KEM standardized by NIST [14] is based on LWE; and 2) current publicly available Homomorphic Encryption (HE) libraries are based on LWE. NIST KEM schemes use random secrets, but homomorphic encryption schemes use binary or ternary secrets, for efficiency reasons. In particular, sparse binary secrets have been proposed, but not standardized [2], for HE.\u003c/p\u003e\n\u003cp\u003ePrior work SALSA [49] demonstrated a new machine learning attack on sparse binary secrets for the LWE problem in small dimensions (up to n = 128) and low Hamming weights (up to h = 4). However, this attack assumed access to millions of LWE samples, and was not scaled to higher Hamming weights or dimensions.\u003c/p\u003e\n\u003cp\u003eOur attack, PICANTE, reduces the number of samples required to just m = 4n samples. Moreover, it can recover secrets with much larger dimensions (up to 350) and Hamming weights (roughly n/10, or h = 33 for n = 300). To achieve this, we introduce a preprocessing step which allows us to generate the training data from a linear number of samples and changes the distribution of the training data to improve transformer training. We also improve the distinguisher/secret recovery methods of SALSA and introduce a novel cross-attention recovery mechanism which allows us to read-off the secret directly from the trained models.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/340\" rel=\"ugc\"\u003eIACR\u003c/a\u003e\u003c/p\u003e\n","description_plain":"The Learning With Errors (LWE) problem is one of the major hard problems in post-quantum cryptography. For example, 1) the only Key Exchange Mechanism KEM standardized by NIST [14] is based on LWE; and 2) current publicly available Homomorphic Encryption (HE) libraries are based on LWE. NIST KEM schemes use random secrets, but homomorphic encryption schemes use binary or ternary secrets, for efficiency reasons. In particular, sparse binary secrets have been proposed, but not standardized [2], for HE.\r\n\r\n  Prior work SALSA [49] demonstrated a new machine learning attack on sparse binary secrets for the LWE problem in small dimensions (up to n = 128) and low Hamming weights (up to h = 4). However, this attack assumed access to millions of LWE samples, and was not scaled to higher Hamming weights or dimensions.\r\n\r\n  Our attack, PICANTE, reduces the number of samples required to just m = 4n samples. Moreover, it can recover secrets with much larger dimensions (up to 350) and Hamming weights (roughly n/10, or h = 33 for n = 300). To achieve this, we introduce a preprocessing step which allows us to generate the training data from a linear number of samples and changes the distribution of the training data to improve transformer training. We also improve the distinguisher/secret recovery methods of SALSA and introduce a novel cross-attention recovery mechanism which allows us to read-off the secret directly from the trained models.\r\n\r\n[IACR](https://eprint.iacr.org/2023/340)","comments_url":"https://lobste.rs/s/0grcqx/salsa_picante_machine_learning_attack_on","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["ai","cryptography","pdf"]},{"short_id":"xktuab","short_id_url":"https://lobste.rs/s/xktuab","created_at":"2023-03-11T21:53:59.000-06:00","title":"Automatic verification of transparency protocols (extended version)","url":"https://arxiv.org/pdf/2303.04500.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eWe introduce new features in ProVerif, an automatic tool for verifying security protocols, and a methodology for using them. This methodology and these features are aimed at protocols which involve sophisticated data types that have strong properties, such as Merkle trees, which allow compact proofs of data presence and tree extension. Such data types are widely used in protocols in systems that use distributed ledgers and/or blockchains.\u003c/p\u003e\n\u003cp\u003eWith our methodology, it is possible to describe the data type quite abstractly, using ProVerif axioms, and prove the correctness of the protocol using those axioms as assumptions. Then, in separate steps, one can define one or more concrete implementations of the data type, and again use ProVerif to show that the implementations satisfy the assumptions that were coded as axioms. This helps make compositional proofs, splitting the proof burden into several manageable pieces.\nTo enable this methodology, we introduce new capabilities in ProVerif, by extending the class of lemmas and axioms that it can reason with. Specifically, we allow user-defined predicates, attacker predicates and message predicates to appear in lemmas and axioms. We show the soundness of the implementation of this idea with respect to the semantics.\u003c/p\u003e\n\u003cp\u003eWe illustrate the methodology and features by providing the first formal verification of two transparency protocols which precisely models the Merkle tree data structure. The two protocols are transparent decryption and certificate transparency. Transparent decryption is a way of ensuring that decryption operations are visible by people who are affected by them. This can be used to support privacy: it can mean that a subject is alerted to the fact that information about them has been decrypted. Certificate transparency is an Internet security standard for monitoring and auditing the issuance of digital certificates.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.04500\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":" We introduce new features in ProVerif, an automatic tool for verifying security protocols, and a methodology for using them. This methodology and these features are aimed at protocols which involve sophisticated data types that have strong properties, such as Merkle trees, which allow compact proofs of data presence and tree extension. Such data types are widely used in protocols in systems that use distributed ledgers and/or blockchains.\r\n\r\nWith our methodology, it is possible to describe the data type quite abstractly, using ProVerif axioms, and prove the correctness of the protocol using those axioms as assumptions. Then, in separate steps, one can define one or more concrete implementations of the data type, and again use ProVerif to show that the implementations satisfy the assumptions that were coded as axioms. This helps make compositional proofs, splitting the proof burden into several manageable pieces.\r\nTo enable this methodology, we introduce new capabilities in ProVerif, by extending the class of lemmas and axioms that it can reason with. Specifically, we allow user-defined predicates, attacker predicates and message predicates to appear in lemmas and axioms. We show the soundness of the implementation of this idea with respect to the semantics.\r\n\r\nWe illustrate the methodology and features by providing the first formal verification of two transparency protocols which precisely models the Merkle tree data structure. The two protocols are transparent decryption and certificate transparency. Transparent decryption is a way of ensuring that decryption operations are visible by people who are affected by them. This can be used to support privacy: it can mean that a subject is alerted to the fact that information about them has been decrypted. Certificate transparency is an Internet security standard for monitoring and auditing the issuance of digital certificates. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.04500)","comments_url":"https://lobste.rs/s/xktuab/automatic_verification_transparency","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["formalmethods","pdf"]},{"short_id":"19yoto","short_id_url":"https://lobste.rs/s/19yoto","created_at":"2023-03-11T21:53:13.000-06:00","title":"EavesDroid : Eavesdropping User Behaviors via OS Side-Channels on Smartphones","url":"https://arxiv.org/pdf/2303.03700.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eAs the Internet of Things (IoT) continues to grow, smartphones have become an integral part of IoT systems. However, with the increasing amount of personal information stored on smartphones, users’ privacy is at risk of being compromised by malicious attackers. Malware detection engines are commonly installed on smartphones to defend against these attacks, but new attacks that can evade these defenses may still emerge. In this paper, we present EavesDroid, a new side-channel attack on Android smartphones that allows an unprivileged attacker to accurately infer fine-grained user behaviors (e.g. viewing messages, playing videos) through the on-screen operations. Our attack relies on the correlation between user behaviors and the return values of system calls. The fact that these return values are affected by many factors, resulting in fluctuation and misalignment, makes the attack more challenging. Therefore, we build a CNN-GRU classification model, apply min-max normalization to the raw data and combine multiple features to identify the fine-grained user behaviors. A series of experiments on different models and systems of Android smartphones show that, EavesDroid can achieve an accuracy of 98% and 86% for already considered user behaviors in test set and real-world settings. To prevent this attack, we recommend malware detection, obfuscating return values or restricting applications from reading vulnerable return values.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.03700\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"As the Internet of Things (IoT) continues to grow, smartphones have become an integral part of IoT systems. However, with the increasing amount of personal information stored on smartphones, users' privacy is at risk of being compromised by malicious attackers. Malware detection engines are commonly installed on smartphones to defend against these attacks, but new attacks that can evade these defenses may still emerge. In this paper, we present EavesDroid, a new side-channel attack on Android smartphones that allows an unprivileged attacker to accurately infer fine-grained user behaviors (e.g. viewing messages, playing videos) through the on-screen operations. Our attack relies on the correlation between user behaviors and the return values of system calls. The fact that these return values are affected by many factors, resulting in fluctuation and misalignment, makes the attack more challenging. Therefore, we build a CNN-GRU classification model, apply min-max normalization to the raw data and combine multiple features to identify the fine-grained user behaviors. A series of experiments on different models and systems of Android smartphones show that, EavesDroid can achieve an accuracy of 98% and 86% for already considered user behaviors in test set and real-world settings. To prevent this attack, we recommend malware detection, obfuscating return values or restricting applications from reading vulnerable return values. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.03700)","comments_url":"https://lobste.rs/s/19yoto/eavesdroid_eavesdropping_user","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["android","pdf","privacy","security"]},{"short_id":"ulahc7","short_id_url":"https://lobste.rs/s/ulahc7","created_at":"2023-03-11T21:52:08.000-06:00","title":"SCRAMBLE-CFI: Mitigating Fault-Induced Control-Flow Attacks on OpenTitan","url":"https://arxiv.org/pdf/2303.03711.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eSecure elements physically exposed to adversaries are frequently targeted by fault attacks. These attacks can be utilized to hijack the control-flow of software allowing the attacker to bypass security measures, extract sensitive data, or gain full code execution. In this paper, we systematically analyze the threat vector of fault-induced control-flow manipulations on the open-source OpenTitan secure element. Our thorough analysis reveals that current countermeasures of this chip either induce large area overheads or still cannot prevent the attacker from exploiting the identified threats. In this context, we introduce SCRAMBLE-CFI, an encryption-based control-flow integrity scheme utilizing existing hardware features of OpenTitan. SCRAMBLE-CFI confines, with minimal hardware overhead, the impact of fault-induced control-flow attacks by encrypting each function with a different encryption tweak at load-time. At runtime, code only can be successfully decrypted when the correct decryption tweak is active. We open-source our hardware changes and release our LLVM toolchain automatically protecting programs. Our analysis shows that SCRAMBLE-CFI complementarily enhances security guarantees of OpenTitan with a negligible hardware overhead of less than 3.97 % and a runtime overhead of 7.02 % for the Embench-IoT benchmarks.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.03711\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"Secure elements physically exposed to adversaries are frequently targeted by fault attacks. These attacks can be utilized to hijack the control-flow of software allowing the attacker to bypass security measures, extract sensitive data, or gain full code execution. In this paper, we systematically analyze the threat vector of fault-induced control-flow manipulations on the open-source OpenTitan secure element. Our thorough analysis reveals that current countermeasures of this chip either induce large area overheads or still cannot prevent the attacker from exploiting the identified threats. In this context, we introduce SCRAMBLE-CFI, an encryption-based control-flow integrity scheme utilizing existing hardware features of OpenTitan. SCRAMBLE-CFI confines, with minimal hardware overhead, the impact of fault-induced control-flow attacks by encrypting each function with a different encryption tweak at load-time. At runtime, code only can be successfully decrypted when the correct decryption tweak is active. We open-source our hardware changes and release our LLVM toolchain automatically protecting programs. Our analysis shows that SCRAMBLE-CFI complementarily enhances security guarantees of OpenTitan with a negligible hardware overhead of less than 3.97 % and a runtime overhead of 7.02 % for the Embench-IoT benchmarks. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.03711)","comments_url":"https://lobste.rs/s/ulahc7/scramble_cfi_mitigating_fault_induced","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["pdf","security"]},{"short_id":"irponm","short_id_url":"https://lobste.rs/s/irponm","created_at":"2023-03-11T21:51:06.000-06:00","title":"A Vulnerability in Implementations of SHA-3, SHAKE, EdDSA, and Other NIST-Approved Algorithm","url":"https://eprint.iacr.org/2023/331.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThis paper describes a vulnerability in several implementations of the Secure Hash Algorithm 3 (SHA-3) that have been released by its designers. The vulnerability has been present since the final-round update of Keccak was submitted to the National Institute of Standards and Technology (NIST) SHA-3 hash function competition in January 2011, and is present in the eXtended Keccak Code Package (XKCP) of the Keccak team. It affects all software projects that have integrated this code, such as the scripting languages Python and PHP Hypertext Preprocessor (PHP). The vulnerability is a buffer overflow that allows attacker-controlled values to be eXclusive-ORed (XORed) into memory (without any restrictions on values to be XORed and even far beyond the location of the original buffer), thereby making many standard protection measures against buffer overflows (e.g., canary values) completely ineffective. First, we provide Python and PHP scripts that cause segmentation faults when vulnerable versions of the interpreters are used. Then, we show how this vulnerability can be used to construct second preimages and preimages for the implementation, and we provide a specially constructed file that, when hashed, allows the attacker to execute arbitrary code on the victim’s device. The vulnerability applies to all hash value sizes, and all 64-bit Windows, Linux, and macOS operating systems, and may also impact cryptographic algorithms that require SHA-3 or its variants, such as the Edwards-curve Digital Signature Algorithm (EdDSA) when the Edwards448 curve is used. We introduce the Init-Update-Final Test (IUFT) to detect this vulnerability in implementations.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/331\" rel=\"ugc\"\u003eIACR\u003c/a\u003e\u003c/p\u003e\n","description_plain":"This paper describes a vulnerability in several implementations of the Secure Hash Algorithm 3 (SHA-3) that have been released by its designers. The vulnerability has been present since the final-round update of Keccak was submitted to the National Institute of Standards and Technology (NIST) SHA-3 hash function competition in January 2011, and is present in the eXtended Keccak Code Package (XKCP) of the Keccak team. It affects all software projects that have integrated this code, such as the scripting languages Python and PHP Hypertext Preprocessor (PHP). The vulnerability is a buffer overflow that allows attacker-controlled values to be eXclusive-ORed (XORed) into memory (without any restrictions on values to be XORed and even far beyond the location of the original buffer), thereby making many standard protection measures against buffer overflows (e.g., canary values) completely ineffective. First, we provide Python and PHP scripts that cause segmentation faults when vulnerable versions of the interpreters are used. Then, we show how this vulnerability can be used to construct second preimages and preimages for the implementation, and we provide a specially constructed file that, when hashed, allows the attacker to execute arbitrary code on the victim's device. The vulnerability applies to all hash value sizes, and all 64-bit Windows, Linux, and macOS operating systems, and may also impact cryptographic algorithms that require SHA-3 or its variants, such as the Edwards-curve Digital Signature Algorithm (EdDSA) when the Edwards448 curve is used. We introduce the Init-Update-Final Test (IUFT) to detect this vulnerability in implementations.\r\n\r\n[IACR](https://eprint.iacr.org/2023/331)","comments_url":"https://lobste.rs/s/irponm/vulnerability_implementations_sha_3","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"pvtubk","short_id_url":"https://lobste.rs/s/pvtubk","created_at":"2023-03-11T21:50:30.000-06:00","title":"Caveat Implementor! Key Recovery Attacks on MEGA","url":"https://eprint.iacr.org/2023/329.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eMEGA is a large-scale cloud storage and communication platform that aims to provide end-to-end encryption for stored data. A recent analysis by Backendal, Haller and Paterson (IEEE S\u0026amp;P 2023) invalidated these security claims by presenting practical attacks against MEGA that could be mounted by the MEGA service provider. In response, the MEGA developers added lightweight sanity checks on the user RSA private keys used in MEGA, sufficient to prevent the previous attacks.\u003c/p\u003e\n\u003cp\u003eWe analyse these new sanity checks and show how they themselves can be exploited to mount novel attacks on MEGA that recover a target user’s RSA private key with only slightly higher attack complexity than the original attacks. We identify the presence of an ECB encryption oracle under a target user’s master key in the MEGA system; this oracle provides our adversary with the ability to partially overwrite a target user’s RSA private key with chosen data, a powerful capability that we use in our attacks. We then present two distinct types of attack, each type exploiting different error conditions arising in the sanity checks and in subsequent cryptographic processing during MEGA’s user authentication procedure. The first type appears to be novel and exploits the manner in which the MEGA code handles modular inversion when recomputing \u003ccode\u003eu = q^-1 mod p\u003c/code\u003e. The second can be viewed as a small subgroup attack (van Oorschot and Wiener, EUROCRYPT 1996, Lim and Lee, CRYPTO 1998). We prototype the attacks and show that they work in practice.\u003c/p\u003e\n\u003cp\u003eAs a side contribution, we show how to improve the RSA key recovery attack of Backendal-Haller-Paterson against the unpatched version of MEGA to require only 2 logins instead of the original 512.\u003c/p\u003e\n\u003cp\u003eWe conclude by discussing wider lessons about secure implementation of cryptography that our work surfaces.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/329\" rel=\"ugc\"\u003eIACR\u003c/a\u003e\u003c/p\u003e\n","description_plain":"MEGA is a large-scale cloud storage and communication platform that aims to provide end-to-end encryption for stored data. A recent analysis by Backendal, Haller and Paterson (IEEE S\u0026P 2023) invalidated these security claims by presenting practical attacks against MEGA that could be mounted by the MEGA service provider. In response, the MEGA developers added lightweight sanity checks on the user RSA private keys used in MEGA, sufficient to prevent the previous attacks.\r\n\r\nWe analyse these new sanity checks and show how they themselves can be exploited to mount novel attacks on MEGA that recover a target user's RSA private key with only slightly higher attack complexity than the original attacks. We identify the presence of an ECB encryption oracle under a target user's master key in the MEGA system; this oracle provides our adversary with the ability to partially overwrite a target user's RSA private key with chosen data, a powerful capability that we use in our attacks. We then present two distinct types of attack, each type exploiting different error conditions arising in the sanity checks and in subsequent cryptographic processing during MEGA's user authentication procedure. The first type appears to be novel and exploits the manner in which the MEGA code handles modular inversion when recomputing `u = q^-1 mod p`. The second can be viewed as a small subgroup attack (van Oorschot and Wiener, EUROCRYPT 1996, Lim and Lee, CRYPTO 1998). We prototype the attacks and show that they work in practice.\r\n\r\nAs a side contribution, we show how to improve the RSA key recovery attack of Backendal-Haller-Paterson against the unpatched version of MEGA to require only 2 logins instead of the original 512.\r\n\r\nWe conclude by discussing wider lessons about secure implementation of cryptography that our work surfaces.\r\n\r\n[IACR](https://eprint.iacr.org/2023/329)","comments_url":"https://lobste.rs/s/pvtubk/caveat_implementor_key_recovery_attacks","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"byivq1","short_id_url":"https://lobste.rs/s/byivq1","created_at":"2023-03-11T21:49:19.000-06:00","title":"Modeling and Exploration of Gain Competition Attacks in Optical Network-on-Chip Architectures","url":"https://arxiv.org/pdf/2303.01550.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eNetwork-on-Chip (NoC) enables energy-efficient communication between numerous components in System-on-Chip architectures. The optical NoC is widely considered a key technology to overcome the bandwidth and energy limitations of traditional electrical on-chip interconnects. While optical NoC can offer high performance, they come with inherent security vulnerabilities due to the nature of optical interconnects.\u003c/p\u003e\n\u003cp\u003eIn this paper, we investigate the gain competition attack in optical NoCs, which can be initiated by an attacker injecting a high-power signal to the optical waveguide, robbing the legitimate signals of amplification. To the best of our knowledge, our proposed approach is the first attempt to investigate gain competition attacks as a security threat in optical NoCs. We model the attack and analyze its effects on optical NoC performance. We also propose potential attack detection techniques and countermeasures to mitigate the attack. Our experimental evaluation using different NoC topologies and diverse traffic patterns demonstrates the effectiveness of our modeling and exploration of gain competition attacks in optical NoC architectures.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.01550\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"Network-on-Chip (NoC) enables energy-efficient communication between numerous components in System-on-Chip architectures. The optical NoC is widely considered a key technology to overcome the bandwidth and energy limitations of traditional electrical on-chip interconnects. While optical NoC can offer high performance, they come with inherent security vulnerabilities due to the nature of optical interconnects.\r\n\r\nIn this paper, we investigate the gain competition attack in optical NoCs, which can be initiated by an attacker injecting a high-power signal to the optical waveguide, robbing the legitimate signals of amplification. To the best of our knowledge, our proposed approach is the first attempt to investigate gain competition attacks as a security threat in optical NoCs. We model the attack and analyze its effects on optical NoC performance. We also propose potential attack detection techniques and countermeasures to mitigate the attack. Our experimental evaluation using different NoC topologies and diverse traffic patterns demonstrates the effectiveness of our modeling and exploration of gain competition attacks in optical NoC architectures.\r\n\r\n[arXiv](https://arxiv.org/abs/2303.01550)","comments_url":"https://lobste.rs/s/byivq1/modeling_exploration_gain_competition","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["hardware","pdf","security"]},{"short_id":"eo34qk","short_id_url":"https://lobste.rs/s/eo34qk","created_at":"2023-03-11T21:47:59.000-06:00","title":"Exploiting Input Sanitization for Regex Denial of Service","url":"https://arxiv.org/pdf/2303.01996","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eWeb services use server-side input sanitization to guard against harmful input. Some web services publish their sanitization logic to make their client interface more usable, e.g., allowing clients to debug invalid requests locally. However, this usability practice poses a security risk. Specifically, services may share the regexes they use to sanitize input strings – and regex-based denial of service (ReDoS) is an emerging threat. Although prominent service outages caused by ReDoS have spurred interest in this topic, we know little about the degree to which live web services are vulnerable to ReDoS.\u003c/p\u003e\n\u003cp\u003eIn this paper, we conduct the first black-box study measuring the extent of ReDoS vulnerabilities in live web services. We apply the Consistent Sanitization Assumption: that client-side sanitization logic, including regexes, is consistent with the sanitization logic on the server-side. We identify a service’s regex-based input sanitization in its HTML forms or its API, find vulnerable regexes among these regexes, craft ReDoS probes, and pinpoint vulnerabilities. We analyzed the HTML forms of 1,000 services and the APIs of 475 services. Of these, 355 services publish regexes; 17 services publish unsafe regexes; and 6 services are vulnerable to ReDoS through their APIs (6 domains; 15 subdomains). Both Microsoft and Amazon Web Services patched their web services as a result of our disclosure. Since these vulnerabilities were from API specifications, not HTML forms, we proposed a ReDoS defense for a popular API validation library, and our patch has been merged. To summarize: in client-visible sanitization logic, some web services advertise ReDoS vulnerabilities in plain sight. Our results motivate short-term patches and long-term fundamental solutions.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.01996\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"Web services use server-side input sanitization to guard against harmful input. Some web services publish their sanitization logic to make their client interface more usable, e.g., allowing clients to debug invalid requests locally. However, this usability practice poses a security risk. Specifically, services may share the regexes they use to sanitize input strings -- and regex-based denial of service (ReDoS) is an emerging threat. Although prominent service outages caused by ReDoS have spurred interest in this topic, we know little about the degree to which live web services are vulnerable to ReDoS.\r\n\r\nIn this paper, we conduct the first black-box study measuring the extent of ReDoS vulnerabilities in live web services. We apply the Consistent Sanitization Assumption: that client-side sanitization logic, including regexes, is consistent with the sanitization logic on the server-side. We identify a service's regex-based input sanitization in its HTML forms or its API, find vulnerable regexes among these regexes, craft ReDoS probes, and pinpoint vulnerabilities. We analyzed the HTML forms of 1,000 services and the APIs of 475 services. Of these, 355 services publish regexes; 17 services publish unsafe regexes; and 6 services are vulnerable to ReDoS through their APIs (6 domains; 15 subdomains). Both Microsoft and Amazon Web Services patched their web services as a result of our disclosure. Since these vulnerabilities were from API specifications, not HTML forms, we proposed a ReDoS defense for a popular API validation library, and our patch has been merged. To summarize: in client-visible sanitization logic, some web services advertise ReDoS vulnerabilities in plain sight. Our results motivate short-term patches and long-term fundamental solutions. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.01996)","comments_url":"https://lobste.rs/s/eo34qk/exploiting_input_sanitization_for_regex","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["pdf","programming","security"]},{"short_id":"86ru2o","short_id_url":"https://lobste.rs/s/86ru2o","created_at":"2023-03-11T21:46:07.000-06:00","title":"A Novel Related Nonce Attack for ECDSA","url":"https://eprint.iacr.org/2023/305.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eWe describe a new related nonce attack able to extract the\noriginal signing key from a small collection of ECDSA signatures generated with weak PRNGs. Under suitable conditions on the modulo order\nof the PRNG, we are able to attack linear, quadratic, cubic as well as\narbitrary degree recurrence relations (with unknown coefficients) with\nfew signatures and in negligible time. We also show that for any collection of randomly generated ECDSA nonces, there is one more nonce that\ncan be added following the implicit recurrence relation, and that would\nallow retrieval of the private key; we exploit this fact to present a novel\nrogue nonce attack against ECDSA. Up to our knowledge, this is the\nfirst known attack exploiting generic and unknown high-degree algebraic\nrelations between nonces that do not require assumptions on the value\nof single bits or bit sequences (e.g. prefixes and suffixes).\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/305\" rel=\"ugc\"\u003eIACR\u003c/a\u003e\u003c/p\u003e\n","description_plain":"We describe a new related nonce attack able to extract the\r\noriginal signing key from a small collection of ECDSA signatures generated with weak PRNGs. Under suitable conditions on the modulo order\r\nof the PRNG, we are able to attack linear, quadratic, cubic as well as\r\narbitrary degree recurrence relations (with unknown coefficients) with\r\nfew signatures and in negligible time. We also show that for any collection of randomly generated ECDSA nonces, there is one more nonce that\r\ncan be added following the implicit recurrence relation, and that would\r\nallow retrieval of the private key; we exploit this fact to present a novel\r\nrogue nonce attack against ECDSA. Up to our knowledge, this is the\r\nfirst known attack exploiting generic and unknown high-degree algebraic\r\nrelations between nonces that do not require assumptions on the value\r\nof single bits or bit sequences (e.g. prefixes and suffixes).\r\n\r\n[IACR](https://eprint.iacr.org/2023/305)","comments_url":"https://lobste.rs/s/86ru2o/novel_related_nonce_attack_for_ecdsa","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"0fmxda","short_id_url":"https://lobste.rs/s/0fmxda","created_at":"2023-03-11T21:45:16.000-06:00","title":"Optimization and Amplification of Cache Side Channel Signals","url":"https://arxiv.org/pdf/2303.00122.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eIn cache-based side channel attacks, an attacker infers information about the victim based on the presence, or lack thereof, of one or more cachelines. Determining a cacheline’s presence, which we refer to as “reading the signal”, typically requires testing the access time of the line using a suitably high precision timer. In this paper we introduce novel gadgets which leverage CPU speculation to enable modification of these signals, before they are read, for a variety of purposes. First, these gadgets enable an attacker to optimize cache-based side channel attacks by evaluating arbitrary logic functions on cacheline signals prior to their measurement. Second, we demonstrate amplification techniques that enable an attacker to read a signal even if no high precision timer is available. Combined, these techniques can be used to improve existing side channel attacks even if timer access is limited. We evaluate the effectiveness of these techniques on a modern x86 CPU and demonstrate that when properly tuned, cache side channel signals can be reliably modified with near 100% accuracy and are able to be read with a timer as coarse as 100ms or more.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.00122\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"In cache-based side channel attacks, an attacker infers information about the victim based on the presence, or lack thereof, of one or more cachelines. Determining a cacheline's presence, which we refer to as \"reading the signal\", typically requires testing the access time of the line using a suitably high precision timer. In this paper we introduce novel gadgets which leverage CPU speculation to enable modification of these signals, before they are read, for a variety of purposes. First, these gadgets enable an attacker to optimize cache-based side channel attacks by evaluating arbitrary logic functions on cacheline signals prior to their measurement. Second, we demonstrate amplification techniques that enable an attacker to read a signal even if no high precision timer is available. Combined, these techniques can be used to improve existing side channel attacks even if timer access is limited. We evaluate the effectiveness of these techniques on a modern x86 CPU and demonstrate that when properly tuned, cache side channel signals can be reliably modified with near 100% accuracy and are able to be read with a timer as coarse as 100ms or more. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.00122)","comments_url":"https://lobste.rs/s/0fmxda/optimization_amplification_cache_side","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["assembly","hardware","pdf","security"]},{"short_id":"2raiki","short_id_url":"https://lobste.rs/s/2raiki","created_at":"2023-03-11T21:44:31.000-06:00","title":"Dishing Out DoS: How to Disable and Secure the Starlink User Terminal","url":"https://arxiv.org/pdf/2303.00582.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eSatellite user terminals are a promising target for adversaries seeking to target satellite communication networks. Despite this, many protections commonly found in terrestrial routers are not present in some user terminals.\nAs a case study we audit the attack surface presented by the Starlink router’s admin interface, using fuzzing to uncover a denial of service attack on the Starlink user terminal. We explore the attack’s impact, particularly in the cases of drive-by attackers, and attackers that are able to maintain a continuous presence on the network. Finally, we discuss wider implications, looking at lessons learned in terrestrial router security, and how to properly implement them in this new context.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2303.00582\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"Satellite user terminals are a promising target for adversaries seeking to target satellite communication networks. Despite this, many protections commonly found in terrestrial routers are not present in some user terminals.\r\nAs a case study we audit the attack surface presented by the Starlink router's admin interface, using fuzzing to uncover a denial of service attack on the Starlink user terminal. We explore the attack's impact, particularly in the cases of drive-by attackers, and attackers that are able to maintain a continuous presence on the network. Finally, we discuss wider implications, looking at lessons learned in terrestrial router security, and how to properly implement them in this new context. \r\n\r\n[arXiv](https://arxiv.org/abs/2303.00582)","comments_url":"https://lobste.rs/s/2raiki/dishing_out_dos_how_disable_secure","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["pdf","security"]},{"short_id":"chrqgl","short_id_url":"https://lobste.rs/s/chrqgl","created_at":"2023-03-11T21:42:57.000-06:00","title":"Analysis of RIPEMD-160: New Collision Attacks and Finding Characteristics with MILP","url":"https://eprint.iacr.org/2023/277.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThe hash function RIPEMD-160 is an ISO/IEC standard and is being used to generate the bitcoin address together with SHA-256. Despite the fact that many hash functions in the MD-SHA hash family have been broken, RIPEMD-160 remains secure and the best collision attack could only reach up to 34 out of 80 rounds, which was published at CRYPTO 2019. In this paper, we propose a new collision attack on RIPEMD-160 that can reach up to 36 rounds with time complexity 2^64.5. This new attack is facilitated by a new strategy to choose the message differences and new techniques to simultaneously handle the differential conditions on both branches. Moreover, different from all the previous work on RIPEMD-160, we utilize a MILP-based method to search for differential characteristics, where we construct a model to accurately describe the signed difference transitions through its round function. As far as we know, this is the first model targeting the signed difference transitions for the MD-SHA hash family. Indeed, we are more motivated to design this model by the fact that many automatic tools to search for such differential characteristics are not publicly available and implementing them from  scratch is too time-consuming and difficult. Hence, we expect that this can be an alternative easy tool for future research, which only requires to write down some simple linear inequalities.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/277\" rel=\"ugc\"\u003eIACR\u003c/a\u003e\u003c/p\u003e\n","description_plain":"The hash function RIPEMD-160 is an ISO/IEC standard and is being used to generate the bitcoin address together with SHA-256. Despite the fact that many hash functions in the MD-SHA hash family have been broken, RIPEMD-160 remains secure and the best collision attack could only reach up to 34 out of 80 rounds, which was published at CRYPTO 2019. In this paper, we propose a new collision attack on RIPEMD-160 that can reach up to 36 rounds with time complexity 2^64.5. This new attack is facilitated by a new strategy to choose the message differences and new techniques to simultaneously handle the differential conditions on both branches. Moreover, different from all the previous work on RIPEMD-160, we utilize a MILP-based method to search for differential characteristics, where we construct a model to accurately describe the signed difference transitions through its round function. As far as we know, this is the first model targeting the signed difference transitions for the MD-SHA hash family. Indeed, we are more motivated to design this model by the fact that many automatic tools to search for such differential characteristics are not publicly available and implementing them from  scratch is too time-consuming and difficult. Hence, we expect that this can be an alternative easy tool for future research, which only requires to write down some simple linear inequalities.\r\n\r\n[IACR](https://eprint.iacr.org/2023/277)","comments_url":"https://lobste.rs/s/chrqgl/analysis_ripemd_160_new_collision","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"g1ixka","short_id_url":"https://lobste.rs/s/g1ixka","created_at":"2023-03-11T21:42:09.000-06:00","title":"New Records in Collision Attacks on RIPEMD-160 and SHA-256","url":"https://eprint.iacr.org/2023/285.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eRIPEMD-160 and SHA-256 are two hash functions used to generate the bitcoin address. In particular, RIPEMD-160 is an ISO/IEC standard and SHA-256 has been widely used in the world. Due to their complex designs, the progress to find (semi-free-start) collisions for the two hash functions is slow. Recently at EUROCRYPT 2023, Liu et al. presented the first collision attack on 36 steps of RIPEMD-160 and the first MILP-based method to find collision-generating signed differential characteristics. We continue this line of research and implement the MILP-based method with a SAT/SMT-based method. Furthermore, we observe that the collision attack on RIPEMD-160 can be improved to 40 steps with different message differences. We have practically found a colliding message pair for 40-step RIPEMD-160 in 16 hours with 115 threads. Moreover, we also report the first semi-free-start (SFS) colliding message pair for 39-step SHA-256, which can be found in about 3 hours with 120 threads. These results update the best (SFS) collision attacks on RIPEMD-160 and SHA-256. Especially, we have made some progress on SHA-256 since the last update on (SFS) collision attacks on it at EUROCRYPT 2013, where the first practical SFS collision attack on 38-step SHA-256 was found.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/285\" rel=\"ugc\"\u003eIACR\u003c/a\u003e\u003c/p\u003e\n","description_plain":"RIPEMD-160 and SHA-256 are two hash functions used to generate the bitcoin address. In particular, RIPEMD-160 is an ISO/IEC standard and SHA-256 has been widely used in the world. Due to their complex designs, the progress to find (semi-free-start) collisions for the two hash functions is slow. Recently at EUROCRYPT 2023, Liu et al. presented the first collision attack on 36 steps of RIPEMD-160 and the first MILP-based method to find collision-generating signed differential characteristics. We continue this line of research and implement the MILP-based method with a SAT/SMT-based method. Furthermore, we observe that the collision attack on RIPEMD-160 can be improved to 40 steps with different message differences. We have practically found a colliding message pair for 40-step RIPEMD-160 in 16 hours with 115 threads. Moreover, we also report the first semi-free-start (SFS) colliding message pair for 39-step SHA-256, which can be found in about 3 hours with 120 threads. These results update the best (SFS) collision attacks on RIPEMD-160 and SHA-256. Especially, we have made some progress on SHA-256 since the last update on (SFS) collision attacks on it at EUROCRYPT 2013, where the first practical SFS collision attack on 38-step SHA-256 was found.\r\n\r\n[IACR](https://eprint.iacr.org/2023/285)","comments_url":"https://lobste.rs/s/g1ixka/new_records_collision_attacks_on_ripemd","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"xsxlhh","short_id_url":"https://lobste.rs/s/xsxlhh","created_at":"2023-03-11T21:22:59.000-06:00","title":"The semantics of a simple functional language","url":"https://lawrencecpaulson.github.io/2023/03/08/Fun_Semantics.html","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/xsxlhh/semantics_simple_functional_language","submitter_user":{"username":"amw-zero","created_at":"2021-09-21T19:57:11.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":944,"avatar_url":"/avatars/amw-zero-100.png","invited_by_user":"mrjoes"},"tags":["formalmethods","plt"]},{"short_id":"r7i5as","short_id_url":"https://lobste.rs/s/r7i5as","created_at":"2023-03-11T19:44:53.000-06:00","title":"Embed a Tailscale Funnel in your Go app","url":"https://tailscale.dev/blog/embedded-funnel","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/r7i5as/embed_tailscale_funnel_your_go_app","submitter_user":{"username":"carlmjohnson","created_at":"2021-07-19T11:55:18.000-05:00","is_admin":false,"about":"Carl M. Johnson is a philosopher and programmer, currently employed as the Director of Technology for Spotlight PA.","is_moderator":false,"karma":8766,"avatar_url":"/avatars/carlmjohnson-100.png","invited_by_user":"peterbourgon","github_username":"carlmjohnson","twitter_username":"carlmjohnson"},"tags":["go","networking"]},{"short_id":"44pb79","short_id_url":"https://lobste.rs/s/44pb79","created_at":"2023-03-11T18:25:44.000-06:00","title":"Shell-free scripts with Execa 7","url":"https://medium.com/@ehmicky/shell-free-scripts-with-execa-7-885fb3b42f83","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/44pb79/shell_free_scripts_with_execa_7","submitter_user":{"username":"ehmicky","created_at":"2019-01-21T08:33:02.000-06:00","is_admin":false,"about":"","is_moderator":false,"karma":42,"avatar_url":"/avatars/ehmicky-100.png","invited_by_user":"wink"},"tags":["javascript","nodejs"]},{"short_id":"g7swgc","short_id_url":"https://lobste.rs/s/g7swgc","created_at":"2023-03-11T16:54:30.000-06:00","title":"Counterfeit Chip Detection using Scattering Parameter Analysis","url":"https://arxiv.org/pdf/2302.11034.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThe increase in the number of counterfeit and recycled microelectronic chips in recent years has created significant security and safety concerns in various applications. Hence, detecting such counterfeit chips in electronic systems is critical before deployment in the field. Unfortunately, the conventional verification tools using physical inspection and side-channel methods are costly, unscalable, error-prone, and often incompatible with legacy systems. This paper introduces a generic non-invasive and low-cost counterfeit chip detection based on characterizing the impedance of the system’s power delivery network (PDN). Our method relies on the fact that the impedance of the counterfeit and recycled chips differs from the genuine ones. To sense such impedance variations confidently, we deploy scattering parameters, frequently used for impedance characterization of RF/microwave circuits. Our proposed approach can directly be applied to soldered chips on the system’s PCB and does not require any modifications on the legacy systems. To validate our claims, we perform extensive measurements on genuine and aged samples from two families of STMicroelectronics chips to assess the effectiveness of the proposed approach.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2302.11034\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"The increase in the number of counterfeit and recycled microelectronic chips in recent years has created significant security and safety concerns in various applications. Hence, detecting such counterfeit chips in electronic systems is critical before deployment in the field. Unfortunately, the conventional verification tools using physical inspection and side-channel methods are costly, unscalable, error-prone, and often incompatible with legacy systems. This paper introduces a generic non-invasive and low-cost counterfeit chip detection based on characterizing the impedance of the system's power delivery network (PDN). Our method relies on the fact that the impedance of the counterfeit and recycled chips differs from the genuine ones. To sense such impedance variations confidently, we deploy scattering parameters, frequently used for impedance characterization of RF/microwave circuits. Our proposed approach can directly be applied to soldered chips on the system's PCB and does not require any modifications on the legacy systems. To validate our claims, we perform extensive measurements on genuine and aged samples from two families of STMicroelectronics chips to assess the effectiveness of the proposed approach. \r\n\r\n[arXiv](https://arxiv.org/abs/2302.11034)","comments_url":"https://lobste.rs/s/g7swgc/counterfeit_chip_detection_using","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["hardware","pdf"]},{"short_id":"6fawiq","short_id_url":"https://lobste.rs/s/6fawiq","created_at":"2023-03-11T16:48:35.000-06:00","title":"A wunderBAR Story","url":"http://www.os2museum.com/wp/a-wunderbar-story/","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/6fawiq/wunderbar_story","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["historical"]},{"short_id":"3ycgfx","short_id_url":"https://lobste.rs/s/3ycgfx","created_at":"2023-03-11T16:45:26.000-06:00","title":"Hash Tables FTW","url":"http://www.os2museum.com/wp/hash-tables-ftw/","score":3,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/3ycgfx/hash_tables_ftw","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["performance"]},{"short_id":"1wiec3","short_id_url":"https://lobste.rs/s/1wiec3","created_at":"2023-03-11T16:42:29.000-06:00","title":"Reverse-engineering the register codes for the 8086 processor's microcode","url":"http://www.righto.com/2023/03/8086-register-codes.html","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/1wiec3/reverse_engineering_register_codes_for","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95949,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["hardware","historical","reversing"]},{"short_id":"bonajo","short_id_url":"https://lobste.rs/s/bonajo","created_at":"2023-03-11T14:25:08.000-06:00","title":"Why Are There No Relational DBMSs? (2015)","url":"https://www.dcs.warwick.ac.uk/~hugh/TTM/Why-Are-There-No-Relational-DBMSs.pdf","score":9,"flags":0,"comment_count":2,"description":"\u003cp\u003eabstract:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eI describe the circumstances in which I obtained, in\n1978, a good answer to a burning question: how can\nE.F. Codd’s relational model of data of 1970 [2] be\nproperly embraced by a computer language?\nConsidering that the answer to that question\n(“An Algebra of Relations for Machine\nComputation”) was publicly available in 1975, I\nwonder why it all went wrong and suggest some\npossible reasons.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBut this paragraph on page 11 is perhaps a better abstract, or at least one that explains the title better:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThat situation therefore prompts us to ask, why isn’t SQL truly relational? And, given\nthat it isn’t, why did the industry at large so readily embrace it? Well, we can easily forgive the\nindustry at large, I suppose, because in spite of all its defects, SQL was a hugely significant\nadvance on what we had before—its implementations did offer a fairly intuitive declarative query\nlanguage without the need for loops or pointer chasing, and they did offer a modicum of physical\ndata independence. But why didn’t its inventors come up with a truly relational language? Why\ndid they neglect the obvious need for each of a table’s columns to have a name? Why did they\nallow a table to have two or more columns with the same name? Why did they decide to allow\nmore than one copy of the same row to appear in a table? Why did they invent NULL and\nintroduce that third truth value, UNKNOWN?\u003c/p\u003e\n\u003c/blockquote\u003e\n","description_plain":"abstract:\r\n\r\n\u003e I describe the circumstances in which I obtained, in\r\n\u003e 1978, a good answer to a burning question: how can\r\n\u003e E.F. Codd’s relational model of data of 1970 [2] be\r\n\u003e properly embraced by a computer language?\r\n\u003e Considering that the answer to that question\r\n\u003e (“An Algebra of Relations for Machine\r\n\u003e Computation”) was publicly available in 1975, I\r\n\u003e wonder why it all went wrong and suggest some\r\n\u003e possible reasons.\r\n\r\nBut this paragraph on page 11 is perhaps a better abstract, or at least one that explains the title better:\r\n\r\n\u003e That situation therefore prompts us to ask, why isn’t SQL truly relational? And, given\r\n\u003e that it isn’t, why did the industry at large so readily embrace it? Well, we can easily forgive the\r\n\u003e industry at large, I suppose, because in spite of all its defects, SQL was a hugely significant\r\n\u003e advance on what we had before—its implementations did offer a fairly intuitive declarative query\r\n\u003e language without the need for loops or pointer chasing, and they did offer a modicum of physical\r\n\u003e data independence. But why didn’t its inventors come up with a truly relational language? Why\r\n\u003e did they neglect the obvious need for each of a table’s columns to have a name? Why did they\r\n\u003e allow a table to have two or more columns with the same name? Why did they decide to allow\r\n\u003e more than one copy of the same row to appear in a table? Why did they invent NULL and\r\n\u003e introduce that third truth value, UNKNOWN?","comments_url":"https://lobste.rs/s/bonajo/why_are_there_no_relational_dbmss_2015","submitter_user":{"username":"Sietsebb","created_at":"2017-01-03T08:32:51.000-06:00","is_admin":false,"about":"","is_moderator":false,"karma":2963,"avatar_url":"/avatars/Sietsebb-100.png","invited_by_user":"asthasr"},"tags":["databases","historical","pdf"]},{"short_id":"u5twdx","short_id_url":"https://lobste.rs/s/u5twdx","created_at":"2023-03-11T13:01:22.000-06:00","title":"Andromeda Invaders: Auto Play: Press 'Enter' twice and wait 5 seconds","url":"https://susam.net/invaders.html","score":2,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/u5twdx/andromeda_invaders_auto_play_press_enter","submitter_user":{"username":"susam","created_at":"2020-04-29T15:40:43.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":2068,"avatar_url":"/avatars/susam-100.png","invited_by_user":"premysl","github_username":"susam","twitter_username":"susam"},"tags":["games","show"]}]