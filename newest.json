[{"short_id":"qpoww2","short_id_url":"https://lobste.rs/s/qpoww2","created_at":"2023-01-20T14:19:13.000-06:00","title":"Duet: Creating Harmony between Processors and Embedded FPGAs","url":"https://arxiv.org/pdf/2301.02785.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThe demise of Moore‚Äôs Law has led to the rise of hardware acceleration. However, the focus on accelerating stable algorithms in their entirety neglects the abundant fine-grained acceleration opportunities available in broader domains and squanders host processors‚Äô compute power. This paper presents Duet, a scalable, manycore-FPGA architecture that promotes embedded FPGAs (eFPGA) to be equal peers with processors through non-intrusive, bi-directionally cache-coherent integration. In contrast to existing CPU-FPGA hybrid systems in which the processors play a supportive role, Duet unleashes the full potential of both the processors and the eFPGAs with two classes of post-fabrication enhancements: fine-grained acceleration, which partitions an application into small tasks and offloads the frequently-invoked, compute-intensive ones onto various small accelerators, leveraging the processors to handle dynamic control flow and less accelerable tasks; hardware augmentation, which employs eFPGA-emulated hardware widgets to improve processor efficiency or mitigate software overheads in certain execution models. An RTL-level implementation of Duet is developed to evaluate the architecture with high fidelity. Experiments using synthetic benchmarks show that Duet can reduce the processor-accelerator communication latency by up to 82% and increase the bandwidth by up to 9.5x. The RTL implementation is further evaluated with seven application benchmarks, achieving 1.5-24.9x speedup.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://arxiv.org/abs/2301.02785\" rel=\"ugc\"\u003earXiv\u003c/a\u003e\u003c/p\u003e\n","description_plain":"The demise of Moore's Law has led to the rise of hardware acceleration. However, the focus on accelerating stable algorithms in their entirety neglects the abundant fine-grained acceleration opportunities available in broader domains and squanders host processors' compute power. This paper presents Duet, a scalable, manycore-FPGA architecture that promotes embedded FPGAs (eFPGA) to be equal peers with processors through non-intrusive, bi-directionally cache-coherent integration. In contrast to existing CPU-FPGA hybrid systems in which the processors play a supportive role, Duet unleashes the full potential of both the processors and the eFPGAs with two classes of post-fabrication enhancements: fine-grained acceleration, which partitions an application into small tasks and offloads the frequently-invoked, compute-intensive ones onto various small accelerators, leveraging the processors to handle dynamic control flow and less accelerable tasks; hardware augmentation, which employs eFPGA-emulated hardware widgets to improve processor efficiency or mitigate software overheads in certain execution models. An RTL-level implementation of Duet is developed to evaluate the architecture with high fidelity. Experiments using synthetic benchmarks show that Duet can reduce the processor-accelerator communication latency by up to 82% and increase the bandwidth by up to 9.5x. The RTL implementation is further evaluated with seven application benchmarks, achieving 1.5-24.9x speedup. \r\n\r\n[arXiv](https://arxiv.org/abs/2301.02785)","comments_url":"https://lobste.rs/s/qpoww2/duet_creating_harmony_between","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["hardware","pdf"]},{"short_id":"hqia7g","short_id_url":"https://lobste.rs/s/hqia7g","created_at":"2023-01-20T14:18:44.000-06:00","title":"PiDRAM: A Holistic End-to-end FPGA-based Framework for Processing-in-DRAM","url":"https://dl.acm.org/doi/pdf/10.1145/3563697","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eCommodity DRAM-based processing-using-memory (PuM) techniques that are supported by off-the-shelf DRAM chips present an opportunity for alleviating the data movement bottleneck at low cost. However, sys- tem integration of these techniques imposes non-trivial challenges that are yet to be solved. Potential solu- tions to the integration challenges require appropriate tools to develop any necessary hardware and software components. Unfortunately, current proprietary computing systems, specialized DRAM-testing platforms, or system simulators do not provide the flexibility and/or the holistic system view that is necessary to properly evaluate and deal with the integration challenges of commodity DRAM-based PuM techniques.\nWe design and develop Processing-in-DRAM (PiDRAM), the first flexible end-to-end framework that en- ables system integration studies and evaluation of real, commodity DRAM-based PuM techniques. PiDRAM provides software and hardware components to rapidly integrate PuM techniques across the whole system software and hardware stack. We implement PiDRAM on an FPGA-based RISC-V system. To demonstrate the flexibility and ease of use of PiDRAM, we implement and evaluate two state-of-the-art commodity DRAM- based PuM techniques: (i) in-DRAM copy and initialization (RowClone) and (ii) in-DRAM true random num- ber generation (D-RaNGe). We describe how we solve key integration challenges to make such techniques work and be effective on a real-system prototype, including memory allocation, alignment, and coherence. We observe that end-to-end RowClone speeds up bulk copy and initialization operations by 14.6√ó and 12.6√ó, respectively, over conventional CPU copy, even when coherence is supported with inefficient cache flush operations. Over PiDRAM‚Äôs extensible codebase, integrating both RowClone and D-RaNGe end-to-end on a real RISC-V system prototype takes only 388 lines of Verilog code and 643 lines of C++ code.\u003c/p\u003e\n","description_plain":"Commodity DRAM-based processing-using-memory (PuM) techniques that are supported by off-the-shelf DRAM chips present an opportunity for alleviating the data movement bottleneck at low cost. However, sys- tem integration of these techniques imposes non-trivial challenges that are yet to be solved. Potential solu- tions to the integration challenges require appropriate tools to develop any necessary hardware and software components. Unfortunately, current proprietary computing systems, specialized DRAM-testing platforms, or system simulators do not provide the flexibility and/or the holistic system view that is necessary to properly evaluate and deal with the integration challenges of commodity DRAM-based PuM techniques.\r\nWe design and develop Processing-in-DRAM (PiDRAM), the first flexible end-to-end framework that en- ables system integration studies and evaluation of real, commodity DRAM-based PuM techniques. PiDRAM provides software and hardware components to rapidly integrate PuM techniques across the whole system software and hardware stack. We implement PiDRAM on an FPGA-based RISC-V system. To demonstrate the flexibility and ease of use of PiDRAM, we implement and evaluate two state-of-the-art commodity DRAM- based PuM techniques: (i) in-DRAM copy and initialization (RowClone) and (ii) in-DRAM true random num- ber generation (D-RaNGe). We describe how we solve key integration challenges to make such techniques work and be effective on a real-system prototype, including memory allocation, alignment, and coherence. We observe that end-to-end RowClone speeds up bulk copy and initialization operations by 14.6√ó and 12.6√ó, respectively, over conventional CPU copy, even when coherence is supported with inefficient cache flush operations. Over PiDRAM‚Äôs extensible codebase, integrating both RowClone and D-RaNGe end-to-end on a real RISC-V system prototype takes only 388 lines of Verilog code and 643 lines of C++ code.","comments_url":"https://lobste.rs/s/hqia7g/pidram_holistic_end_end_fpga_based","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["hardware","pdf"]},{"short_id":"2e4imj","short_id_url":"https://lobste.rs/s/2e4imj","created_at":"2023-01-20T14:15:46.000-06:00","title":"A Practical Template Attack on CRYSTALS-Dilithium","url":"https://eprint.iacr.org/2023/050.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThis paper presents a new profiling side-channel attack on the signature scheme¬†CRYSTALS-Dilithium, which has been selected by the NIST as the new primary standard for quantum-safe digital signatures. This algorithm has a constant-time implementation with consideration for side-channel resilience. However, it does not protect against attacks that exploit intermediate data leakage. We exploit such a leakage on a vector generated during the signing process and whose costly protection by masking is a matter of debate. We design a template attack that enables us to efficiently predict whether a given coefficient in one coordinate of this vector is zero or not. Once this value has been completely reconstructed, one can recover, using linear algebra methods, part of the secret key that is sufficient to produce universal forgeries. While our paper deeply discusses the theoretical attack path, it¬†also demonstrates the validity of the assumption regarding the required leakage model, from practical experiments with the reference implementation on an ARM Cortex-M4.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/050\" rel=\"ugc\"\u003eArchive\u003c/a\u003e\u003c/p\u003e\n","description_plain":"This paper presents a new profiling side-channel attack on the signature scheme¬†CRYSTALS-Dilithium, which has been selected by the NIST as the new primary standard for quantum-safe digital signatures. This algorithm has a constant-time implementation with consideration for side-channel resilience. However, it does not protect against attacks that exploit intermediate data leakage. We exploit such a leakage on a vector generated during the signing process and whose costly protection by masking is a matter of debate. We design a template attack that enables us to efficiently predict whether a given coefficient in one coordinate of this vector is zero or not. Once this value has been completely reconstructed, one can recover, using linear algebra methods, part of the secret key that is sufficient to produce universal forgeries. While our paper deeply discusses the theoretical attack path, it¬†also demonstrates the validity of the assumption regarding the required leakage model, from practical experiments with the reference implementation on an ARM Cortex-M4.\r\n\r\n[Archive](https://eprint.iacr.org/2023/050)","comments_url":"https://lobste.rs/s/2e4imj/practical_template_attack_on_crystals","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"sjeaxy","short_id_url":"https://lobste.rs/s/sjeaxy","created_at":"2023-01-20T14:15:10.000-06:00","title":"RDS: FPGA Routing Delay Sensors for Effective Remote Power Analysis Attacks","url":"https://eprint.iacr.org/2023/043.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eState-of-the-art sensors for measuring FPGA voltage fluctuations are time-to-digital converters (TDCs). They allow detecting voltage fluctuations in the order of a few nanoseconds. The key building component of a TDC is a delay line, typically implemented as a chain of fast carry propagation multiplexers. In FPGAs, the fast carry chains are constrained to dedicated logic and routing, and need to be routed strictly vertically. In this work, we present an alternative approach to designing on-chip voltage sensors, in which the FPGA routing resources replace the carry logic. We present three variants of what we name a routing delay sensor (RDS): one vertically constrained, one horizontally constrained, and one free of any constraints. We perform a thorough experimental evaluation on both the Sakura-X side-channel evaluation board and the Alveo U200 datacenter card, to evaluate the performance of the RDS sensors in the context of a remote power side-channel analysis attack. The results show that our best RDS implementation in most cases outperforms the TDC. On average, for breaking the full 128-bit key of an AES-128 cryptographic core, an adversary requires 35% fewer side-channel traces when using the RDS than when using the TDC. Besides making the attack more effective, given the absence of the placement and routing constraint, the RDS sensor is also easier to deploy.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/043\" rel=\"ugc\"\u003eArchive\u003c/a\u003e\u003c/p\u003e\n","description_plain":"State-of-the-art sensors for measuring FPGA voltage fluctuations are time-to-digital converters (TDCs). They allow detecting voltage fluctuations in the order of a few nanoseconds. The key building component of a TDC is a delay line, typically implemented as a chain of fast carry propagation multiplexers. In FPGAs, the fast carry chains are constrained to dedicated logic and routing, and need to be routed strictly vertically. In this work, we present an alternative approach to designing on-chip voltage sensors, in which the FPGA routing resources replace the carry logic. We present three variants of what we name a routing delay sensor (RDS): one vertically constrained, one horizontally constrained, and one free of any constraints. We perform a thorough experimental evaluation on both the Sakura-X side-channel evaluation board and the Alveo U200 datacenter card, to evaluate the performance of the RDS sensors in the context of a remote power side-channel analysis attack. The results show that our best RDS implementation in most cases outperforms the TDC. On average, for breaking the full 128-bit key of an AES-128 cryptographic core, an adversary requires 35% fewer side-channel traces when using the RDS than when using the TDC. Besides making the attack more effective, given the absence of the placement and routing constraint, the RDS sensor is also easier to deploy.\r\n\r\n[Archive](https://eprint.iacr.org/2023/043)","comments_url":"https://lobste.rs/s/sjeaxy/rds_fpga_routing_delay_sensors_for","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["hardware","pdf","security"]},{"short_id":"5szhkh","short_id_url":"https://lobste.rs/s/5szhkh","created_at":"2023-01-20T14:14:42.000-06:00","title":"On Protecting SPHINCS+ Against Fault Attacks","url":"https://eprint.iacr.org/2023/042.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eSPHINCS+ is a hash-based digital signature scheme that was selected by NIST in their post-quantum cryptography standardization process. The establishment of a universal forgery on the seminal scheme SPHINCS was shown to be feasible in practice by injecting a fault when the signing device constructs any non-top subtree. Ever since the attack has been made public, little effort was spent to protect the SPHINCS family against attacks by faults. This paper works in this direction in the context of SPHINCS+ and analyzes the current algorithms that aim to prevent fault-based forgeries.\u003c/p\u003e\n\u003cp\u003eFirst, the paper adapts the original attack to SPHINCS+ reinforced with randomized signing and extends the applicability of the attack to any combination of faulty and valid signatures. Considering the adaptation, the paper then presents a thorough analysis of the attack. In particular, the analysis shows that, with high probability, the security guarantees of SPHINCS+ significantly drop when a single random bit flip occurs anywhere in the signing procedure and that the resulting faulty signature cannot be detected with the verification procedure. The paper shows both in theory and experimentally that the countermeasures based on caching the intermediate W-OTS+s offer a marginally greater protection against unintentional faults, and that such countermeasures are circumvented with a tolerable number of queries in an active attack. Based on these results, the paper recommends real-world deployments of SPHINCS+ to implement redundancy checks.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/042\" rel=\"ugc\"\u003eArchive\u003c/a\u003e\u003c/p\u003e\n","description_plain":"SPHINCS+ is a hash-based digital signature scheme that was selected by NIST in their post-quantum cryptography standardization process. The establishment of a universal forgery on the seminal scheme SPHINCS was shown to be feasible in practice by injecting a fault when the signing device constructs any non-top subtree. Ever since the attack has been made public, little effort was spent to protect the SPHINCS family against attacks by faults. This paper works in this direction in the context of SPHINCS+ and analyzes the current algorithms that aim to prevent fault-based forgeries.\r\n\r\nFirst, the paper adapts the original attack to SPHINCS+ reinforced with randomized signing and extends the applicability of the attack to any combination of faulty and valid signatures. Considering the adaptation, the paper then presents a thorough analysis of the attack. In particular, the analysis shows that, with high probability, the security guarantees of SPHINCS+ significantly drop when a single random bit flip occurs anywhere in the signing procedure and that the resulting faulty signature cannot be detected with the verification procedure. The paper shows both in theory and experimentally that the countermeasures based on caching the intermediate W-OTS+s offer a marginally greater protection against unintentional faults, and that such countermeasures are circumvented with a tolerable number of queries in an active attack. Based on these results, the paper recommends real-world deployments of SPHINCS+ to implement redundancy checks.\r\n\r\n[Archive](https://eprint.iacr.org/2023/042)","comments_url":"https://lobste.rs/s/5szhkh/on_protecting_sphincs_against_fault","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"jq0j3s","short_id_url":"https://lobste.rs/s/jq0j3s","created_at":"2023-01-20T14:13:55.000-06:00","title":"A Closer Look at the Chaotic Ring Oscillators based TRNG Design","url":"https://eprint.iacr.org/2023/040.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eTRNG is an essential component for security applications. A vulnerable TRNG could be exploited to facilitate potential attacks or be related to a reduced key space, and eventually results in a compromised cryptographic system. A digital FIRO-/GARO-based TRNG with high throughput and high entropy rate was introduced by Jovan Dj. Goliƒá (TC‚Äô06). However, the fact that periodic oscillation is a main failure of FIRO-/GARO-based TRNGs is noticed in the paper (Markus Dichtl, ePrint‚Äô15). We verify this problem and estimate the consequential entropy loss using Lyapunov exponents and the test suite of the NIST SP 800-90B standard. To address the problem of periodic oscillations, we propose several implementation guidelines based on a gate-level model, a design methodology to build a reliable GARO-based TRNG, and an online test to improve the robustness of FIRO-/GARO-based TRNGs. The gate-level implementation guidelines illustrate the causes of periodic oscillations, which are verified by actual implementation and bifurcation diagram. Based on the design methodology, a suitable feedback polynomial can be selected by evaluating the feedback polynomials. The analysis and understanding of periodic oscillation and FIRO-/GARO-based TRNGs are deepened by delay adjustment. A TRNG with the selected feedback polynomial may occasionally enter periodic oscillations, due to active attacks and the delay inconstancy of implementations. This inconstancy might be caused by self-heating, temperature and voltage fluctuation, and the process variation among different silicon chips. Thus, an online test module, as one indispensable component of TRNGs, is proposed to detect periodic oscillations. The detected periodic oscillation can be eliminated by adjusting feedback polynomial or delays to improve the robustness. The online test module is composed of a lightweight and responsive detector with a high detection rate, outperforming the existing detector design and statistical tests. The areas, power consumptions and frequencies are evaluated based on the ASIC implementations of a GARO, the sampling circuit and the online test module. The gate-level implementation guidelines promote the future establishment of the stochastic model of FIRO-/GARO-based TRNGs with a deeper understanding.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/040\" rel=\"ugc\"\u003eArchive\u003c/a\u003e\u003c/p\u003e\n","description_plain":"TRNG is an essential component for security applications. A vulnerable TRNG could be exploited to facilitate potential attacks or be related to a reduced key space, and eventually results in a compromised cryptographic system. A digital FIRO-/GARO-based TRNG with high throughput and high entropy rate was introduced by Jovan Dj. Goliƒá (TC‚Äô06). However, the fact that periodic oscillation is a main failure of FIRO-/GARO-based TRNGs is noticed in the paper (Markus Dichtl, ePrint‚Äô15). We verify this problem and estimate the consequential entropy loss using Lyapunov exponents and the test suite of the NIST SP 800-90B standard. To address the problem of periodic oscillations, we propose several implementation guidelines based on a gate-level model, a design methodology to build a reliable GARO-based TRNG, and an online test to improve the robustness of FIRO-/GARO-based TRNGs. The gate-level implementation guidelines illustrate the causes of periodic oscillations, which are verified by actual implementation and bifurcation diagram. Based on the design methodology, a suitable feedback polynomial can be selected by evaluating the feedback polynomials. The analysis and understanding of periodic oscillation and FIRO-/GARO-based TRNGs are deepened by delay adjustment. A TRNG with the selected feedback polynomial may occasionally enter periodic oscillations, due to active attacks and the delay inconstancy of implementations. This inconstancy might be caused by self-heating, temperature and voltage fluctuation, and the process variation among different silicon chips. Thus, an online test module, as one indispensable component of TRNGs, is proposed to detect periodic oscillations. The detected periodic oscillation can be eliminated by adjusting feedback polynomial or delays to improve the robustness. The online test module is composed of a lightweight and responsive detector with a high detection rate, outperforming the existing detector design and statistical tests. The areas, power consumptions and frequencies are evaluated based on the ASIC implementations of a GARO, the sampling circuit and the online test module. The gate-level implementation guidelines promote the future establishment of the stochastic model of FIRO-/GARO-based TRNGs with a deeper understanding.\r\n\r\n[Archive](https://eprint.iacr.org/2023/040)","comments_url":"https://lobste.rs/s/jq0j3s/closer_look_at_chaotic_ring_oscillators","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","hardware","pdf"]},{"short_id":"tzh69d","short_id_url":"https://lobste.rs/s/tzh69d","created_at":"2023-01-20T14:12:55.000-06:00","title":"Glitch-free is not Enough","url":"https://eprint.iacr.org/2023/035.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eToday, resistance to physical defaults is a necessary criterion for masking schemes. In this context, the focus has long been on designing masking schemes guaranteeing security in the presence of glitches. Sadly, immunity against glitches increases latency as registers must stop the glitch propagation. Previous works could reduce the latency by removing register stages but only by impractically increasing the circuit area. Nevertheless, some relatively new attempts avoid glitches by applying DRP logic styles. Promising works in this area include LMDPL, SESYM - both presented at CHES - and Self-Timed Masking - presented at CARDIS - enabling to mask arbitrary circuits with only one cycle latency. However, even if glitches no longer occur, there are other physical defaults that may violate the security of a masked circuit. Imbalanced delay of dual rails is a known problem for the security of DRP logic styles such as WDDL but not covered in formal security models.\nIn this work, we fill the gap by presenting the delay-extended probing security model, a generalization of the popular glitch-extended probing model, covering imbalanced delays. We emphasize the importance of such a model by a formal and practical security analysis of LMDPL, SESYM, and Self-Timed Masking. While we formally prove the delay-extended security of LMDPL and Self-Timed Masking, we show that SESYM fails to provide security under our defined security model what causes detectable leakage through experimental evaluations. Hence, as the message of this work, avoiding glitches in combination with d-probing security is not enough to guarantee physical security in practice.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/035\" rel=\"ugc\"\u003eArchive\u003c/a\u003e\u003c/p\u003e\n","description_plain":"Today, resistance to physical defaults is a necessary criterion for masking schemes. In this context, the focus has long been on designing masking schemes guaranteeing security in the presence of glitches. Sadly, immunity against glitches increases latency as registers must stop the glitch propagation. Previous works could reduce the latency by removing register stages but only by impractically increasing the circuit area. Nevertheless, some relatively new attempts avoid glitches by applying DRP logic styles. Promising works in this area include LMDPL, SESYM - both presented at CHES - and Self-Timed Masking - presented at CARDIS - enabling to mask arbitrary circuits with only one cycle latency. However, even if glitches no longer occur, there are other physical defaults that may violate the security of a masked circuit. Imbalanced delay of dual rails is a known problem for the security of DRP logic styles such as WDDL but not covered in formal security models.\r\nIn this work, we fill the gap by presenting the delay-extended probing security model, a generalization of the popular glitch-extended probing model, covering imbalanced delays. We emphasize the importance of such a model by a formal and practical security analysis of LMDPL, SESYM, and Self-Timed Masking. While we formally prove the delay-extended security of LMDPL and Self-Timed Masking, we show that SESYM fails to provide security under our defined security model what causes detectable leakage through experimental evaluations. Hence, as the message of this work, avoiding glitches in combination with d-probing security is not enough to guarantee physical security in practice.\r\n\r\n[Archive](https://eprint.iacr.org/2023/035)","comments_url":"https://lobste.rs/s/tzh69d/glitch_free_is_not_enough","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["hardware","pdf","security"]},{"short_id":"hmsvro","short_id_url":"https://lobste.rs/s/hmsvro","created_at":"2023-01-20T14:10:42.000-06:00","title":"Prolog Day - 50 years of Prolog","url":"https://www.youtube.com/watch?v=9BW0J7wwqO4","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/hmsvro/prolog_day_50_years_prolog","submitter_user":{"username":"aarroyoc","created_at":"2020-01-25T16:27:21.000-06:00","is_admin":false,"about":"Illuminati developer","is_moderator":false,"karma":589,"avatar_url":"/avatars/aarroyoc-100.png","invited_by_user":"zxtx"},"tags":["programming","video"]},{"short_id":"vyudt1","short_id_url":"https://lobste.rs/s/vyudt1","created_at":"2023-01-20T14:01:04.000-06:00","title":"PROLEAD_SW - Probing-Based Software Leakage Detection for ARM Binaries","url":"https://eprint.iacr.org/2023/034.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eA decisive contribution to the all-embracing protection of cryptographic software, especially on embedded devices, is the protection against SCA attacks. Masking countermeasures can usually be integrated into the software during the design phase. In theory, this should provide reliable protection against such physical attacks. However, the correct application of masking is a non-trivial task which often causes even experts to make mistakes. In addition to human-caused errors, micro-architectural CPU effects can lead even a seemingly theoretically correct implementation to fail satisfying the desired level of security in practice. This originates from different components of the underlying CPU which complicates the tracing of leakage back to a particular source and hence avoids to make general and device-independent statements about its security.\nIn this work, we adapt PROLEAD for the evaluation of masked software, which has recently been presented at CHES 2022 and originally developed as a simulation-based tool to evaluate masked hardware designs.\nWe enable to transfer the already known benefits of PROLEAD into the software world. These include (1) evaluation of larger designs compared to the state of the art, e.g. a full AES masked implementation, and (2) formal verification under the well-established robust probing security model. In short, together with an abstraction model for the micro-architecture, the robust probing model allows us to efficiently detect micro-architectural leakages while being independent of a concrete CPU design. As a concrete result, using PROLEAD_SW we evaluated the security of several publicly available masked software implementations and revealed multiple vulnerabilities.\u003c/p\u003e\n\u003cp\u003eNote: PROLEAD_SW is available via GitHub: \u003ca href=\"https://github.com/ChairImpSec/PROLEAD\" rel=\"ugc\"\u003ehttps://github.com/ChairImpSec/PROLEAD\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/034\" rel=\"ugc\"\u003eArchive\u003c/a\u003e\u003c/p\u003e\n","description_plain":"A decisive contribution to the all-embracing protection of cryptographic software, especially on embedded devices, is the protection against SCA attacks. Masking countermeasures can usually be integrated into the software during the design phase. In theory, this should provide reliable protection against such physical attacks. However, the correct application of masking is a non-trivial task which often causes even experts to make mistakes. In addition to human-caused errors, micro-architectural CPU effects can lead even a seemingly theoretically correct implementation to fail satisfying the desired level of security in practice. This originates from different components of the underlying CPU which complicates the tracing of leakage back to a particular source and hence avoids to make general and device-independent statements about its security.\r\nIn this work, we adapt PROLEAD for the evaluation of masked software, which has recently been presented at CHES 2022 and originally developed as a simulation-based tool to evaluate masked hardware designs.\r\nWe enable to transfer the already known benefits of PROLEAD into the software world. These include (1) evaluation of larger designs compared to the state of the art, e.g. a full AES masked implementation, and (2) formal verification under the well-established robust probing security model. In short, together with an abstraction model for the micro-architecture, the robust probing model allows us to efficiently detect micro-architectural leakages while being independent of a concrete CPU design. As a concrete result, using PROLEAD_SW we evaluated the security of several publicly available masked software implementations and revealed multiple vulnerabilities.\r\n\r\nNote: PROLEAD_SW is available via GitHub: https://github.com/ChairImpSec/PROLEAD\r\n\r\n[Archive](https://eprint.iacr.org/2023/034)","comments_url":"https://lobste.rs/s/vyudt1/prolead_sw_probing_based_software","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["pdf","security"]},{"short_id":"7vgnu7","short_id_url":"https://lobste.rs/s/7vgnu7","created_at":"2023-01-20T13:59:46.000-06:00","title":"A Gentle Tutorial for Lattice-Based Cryptanalysis","url":"https://eprint.iacr.org/2023/032.pdf","score":1,"flags":0,"comment_count":0,"description":"\u003cp\u003eThe applicability of lattice reduction to a wide variety of cryptographic situations makes it an important part of the cryptanalyst‚Äôs toolbox. Despite this, the construction of lattices and use of lattice reduction algorithms for cryptanalysis continue to be somewhat difficult to understand for beginners. This tutorial aims to be a gentle but detailed introduction to lattice-based cryptanalysis targeted towards the novice cryptanalyst with little to no background in lattices. We explain some popular attacks through a conceptual model that simplifies the various components of a lattice attack.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://eprint.iacr.org/2023/032\" rel=\"ugc\"\u003eArchive\u003c/a\u003e\u003c/p\u003e\n","description_plain":"The applicability of lattice reduction to a wide variety of cryptographic situations makes it an important part of the cryptanalyst's toolbox. Despite this, the construction of lattices and use of lattice reduction algorithms for cryptanalysis continue to be somewhat difficult to understand for beginners. This tutorial aims to be a gentle but detailed introduction to lattice-based cryptanalysis targeted towards the novice cryptanalyst with little to no background in lattices. We explain some popular attacks through a conceptual model that simplifies the various components of a lattice attack.\r\n\r\n[Archive](https://eprint.iacr.org/2023/032)","comments_url":"https://lobste.rs/s/7vgnu7/gentle_tutorial_for_lattice_based","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["cryptography","pdf"]},{"short_id":"crc4pt","short_id_url":"https://lobste.rs/s/crc4pt","created_at":"2023-01-20T13:45:04.000-06:00","title":"Printing to stdout with an empty main","url":"https://www.cedricmartens.com/articles/empty_main","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/crc4pt/printing_stdout_with_empty_main","submitter_user":{"username":"raymii","created_at":"2013-11-20T11:58:43.000-06:00","is_admin":false,"about":"üêã\r\nhttps://raymii.org","is_moderator":false,"karma":19293,"avatar_url":"/avatars/raymii-100.png","invited_by_user":"journeysquid"},"tags":["c++"]},{"short_id":"aja2hg","short_id_url":"https://lobste.rs/s/aja2hg","created_at":"2023-01-20T13:27:44.000-06:00","title":"The NixOS ‚Äúsettings‚Äù option: when and how to use it","url":"https://zimbatm.com/notes/the-nixos-settings-option-when-and-how-to-use-it","score":3,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/aja2hg/nixos_settings_option_when_how_use_it","submitter_user":{"username":"l0b0","created_at":"2022-02-14T02:54:31.000-06:00","is_admin":false,"about":"Open source developer.","is_moderator":false,"karma":627,"avatar_url":"/avatars/l0b0-100.png","invited_by_user":"gerikson","github_username":"l0b0"},"tags":["nix"]},{"short_id":"9fwfus","short_id_url":"https://lobste.rs/s/9fwfus","created_at":"2023-01-20T13:16:14.000-06:00","title":"Get Dumber","url":"https://www.supergoodcode.com/get-dumber/","score":2,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/9fwfus/get_dumber","submitter_user":{"username":"calvin","created_at":"2014-07-01T06:47:13.000-05:00","is_admin":false,"about":"Soon we will all have special names... names designed to make the cathode ray tube resonate.\r\n\r\nDavid Chisnall stan account.","is_moderator":false,"karma":95135,"avatar_url":"/avatars/calvin-100.png","invited_by_user":"nbyouri","github_username":"NattyNarwhal"},"tags":["performance"]},{"short_id":"lkle1s","short_id_url":"https://lobste.rs/s/lkle1s","created_at":"2023-01-20T13:01:08.000-06:00","title":"Automatic reference counting vs mark-and-sweep","url":"https://youtu.be/c32zXYAK7CI","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/lkle1s/automatic_reference_counting_vs_mark","submitter_user":{"username":"deavmi","created_at":"2018-06-30T15:27:34.000-05:00","is_admin":false,"about":"I‚Äôm Tristan B. Kildaire (or deavmi on the Internet) and I‚Äôm a computer programmer. I love tinkering around with all the bits of software that my computer runs but typically more on the low-level sides of things. I‚Äôm really interested in how operating systems work as a whole and their components such as kernels, networking stacks, linking-loaders, IPC, paging, virtual memory, file-systems and the list goes on. There‚Äôs so much to learn from understanding these complex systems and each aspect of them never leaves me bored!\r\n\r\nYou could call me a language enthusiast, from the design to the implementation. I always want to know how things work and I‚Äôve even spent time reading the source code for some language runtimes to get a better understanding. If I am feeling creative then I try write my own or write something in Forth! I love building networks too - I have an interest in setting up inter-networks with routing protocols, assigning numbers and setting up tunnels in order to build a huge network that I can play around on. When I‚Äôm not using other peoples' protocols I am busy writing my own to see what I can cobble out to itch my scratch on trying interesting concepts out.\r\n\r\nI like a good glass of red wine and cheese. I have an avid enjoyment for music from the 70s and the 80s and have rather interesting political views (nothing to be alarmed of) but most importantly I like to help others learn and put a smile on their face.","is_moderator":false,"karma":139,"avatar_url":"/avatars/deavmi-100.png","invited_by_user":"duclare","github_username":"deavmi","keybase_signatures":[{"kb_username":"tristankildaire","sig_hash":"4397ec164f1a65b7fd0803bc85cd0b12d06cb2606c2ae0a27795dd90e98e219c0f"}]},"tags":["programming","video"]},{"short_id":"ct1u0s","short_id_url":"https://lobste.rs/s/ct1u0s","created_at":"2023-01-20T09:51:00.000-06:00","title":"Space leaks exploration in Haskell","url":"https://cs.stanford.edu/~sumith/docs/report-spaceleaks.pdf","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/ct1u0s/space_leaks_exploration_haskell","submitter_user":{"username":"srid","created_at":"2019-12-15T08:34:41.000-06:00","is_admin":false,"about":"My latest project: https://github.com/EmaApps/emanote","is_moderator":false,"karma":2626,"avatar_url":"/avatars/srid-100.png","invited_by_user":"Bowero","github_username":"srid","keybase_signatures":[{"kb_username":"srid","sig_hash":"e6701544d15d41cd50cf0b336aa711802c34f53d1df4356ae74f47b9aec5c6700f"}]},"tags":["haskell","pdf"]},{"short_id":"4wcoy5","short_id_url":"https://lobste.rs/s/4wcoy5","created_at":"2023-01-20T09:42:21.000-06:00","title":"Reverse engineering the MacBook clamshell mode","url":"https://alinpanaitiu.com/blog/turn-off-macbook-display-clamshell/","score":19,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/4wcoy5/reverse_engineering_macbook_clamshell","submitter_user":{"username":"alin","created_at":"2020-03-10T05:45:37.000-05:00","is_admin":false,"about":"","is_moderator":false,"karma":130,"avatar_url":"/avatars/alin-100.png","invited_by_user":"ajeetdsouza","github_username":"alin23","twitter_username":"alinp32"},"tags":["mac","reversing"]},{"short_id":"5wggqy","short_id_url":"https://lobste.rs/s/5wggqy","created_at":"2023-01-20T09:06:37.000-06:00","title":"Rust in 2023: Growing up","url":"http://smallcultfollowing.com/babysteps/blog/2023/01/20/rust-in-2023-growing-up/","score":8,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/5wggqy/rust_2023_growing_up","submitter_user":{"username":"matklad","created_at":"2019-07-02T07:23:10.000-05:00","is_admin":false,"about":"Working on IDE support for the Rust language.\r\n\r\nhttps://github.com/matklad","is_moderator":false,"karma":4500,"avatar_url":"/avatars/matklad-100.png","invited_by_user":"skade","github_username":"matklad"},"tags":["rust"]},{"short_id":"njrjkz","short_id_url":"https://lobste.rs/s/njrjkz","created_at":"2023-01-20T08:42:15.000-06:00","title":"the best sudo replacement","url":"https://xeiaso.net/blog/%F0%9F%A5%BA","score":21,"flags":0,"comment_count":9,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/njrjkz/best_sudo_replacement","submitter_user":{"username":"cadey","created_at":"2019-03-08T17:23:38.000-06:00","is_admin":false,"about":"Xe Iaso\r\n\r\nkastermakfa\r\n\r\nko kanro","is_moderator":false,"karma":10316,"avatar_url":"/avatars/cadey-100.png","invited_by_user":"apg","github_username":"Xe","twitter_username":"theprincessxena","keybase_signatures":[{"kb_username":"xena","sig_hash":"a19dbebc33a79273556666968b3ec01d986d34e4a53cc9e0ece695b9bec4cd6c0f"}]},"tags":["satire","security","unix"]},{"short_id":"poj5zg","short_id_url":"https://lobste.rs/s/poj5zg","created_at":"2023-01-20T08:17:51.000-06:00","title":"Debugging a use-after-free in gdb","url":"https://pernos.co/examples/use-after-free","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/poj5zg/debugging_use_after_free_gdb","submitter_user":{"username":"teymour","created_at":"2021-06-01T03:07:56.000-05:00","is_admin":false,"about":"stuck in the computer nightmare","is_moderator":false,"karma":822,"avatar_url":"/avatars/teymour-100.png","invited_by_user":"bkolobara","github_username":"teymour-aldridge"},"tags":["debugging"]},{"short_id":"b75zvp","short_id_url":"https://lobste.rs/s/b75zvp","created_at":"2023-01-20T08:12:25.000-06:00","title":"Backporting changes is clearly hard, which is a good reason to avoid it","url":"https://utcc.utoronto.ca/~cks/space/blog/programming/BackportsAreHard","score":2,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/b75zvp/backporting_changes_is_clearly_hard","submitter_user":{"username":"technetium","created_at":"2020-02-06T19:52:39.000-06:00","is_admin":false,"about":"A sentient lump of a certain high-density material.\r\n\r\nI'm working on a traditional roguelike: [GitHub](https://github.com/kiedtl/roguelike)","is_moderator":false,"karma":5004,"avatar_url":"/avatars/technetium-100.png","invited_by_user":"ngoldbaum","github_username":"kiedtl"},"tags":["linux"]},{"short_id":"6v4xuv","short_id_url":"https://lobste.rs/s/6v4xuv","created_at":"2023-01-20T08:11:28.000-06:00","title":"Rust should own its debugger experience","url":"https://blog.yoshuawuyts.com/rust-should-own-its-debugger-experience/","score":21,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/6v4xuv/rust_should_own_its_debugger_experience","submitter_user":{"username":"rsdbdr203","created_at":"2022-05-26T15:12:50.000-05:00","is_admin":false,"about":"I like Rust, and databases","is_moderator":false,"karma":509,"avatar_url":"/avatars/rsdbdr203-100.png","invited_by_user":"jpn627"},"tags":["rust"]},{"short_id":"rosukz","short_id_url":"https://lobste.rs/s/rosukz","created_at":"2023-01-20T05:59:08.000-06:00","title":"What are you doing this weekend?","url":"","score":7,"flags":0,"comment_count":12,"description":"\u003cp\u003eFeel free to tell what you plan on doing this weekend and even ask for help or feedback.\u003c/p\u003e\n\u003cp\u003ePlease keep in mind it‚Äôs more than OK to do nothing at all too!\u003c/p\u003e\n","description_plain":"Feel free to tell what you plan on doing this weekend and even ask for help or feedback.\r\n\r\nPlease keep in mind it‚Äôs more than OK to do nothing at all too!","comments_url":"https://lobste.rs/s/rosukz/what_are_you_doing_this_weekend","submitter_user":{"username":"caius","created_at":"2014-05-13T06:58:30.000-05:00","is_admin":false,"about":"Compulsive Geek, Ale Connoisseur, Occasionally Responsible Adult.","is_moderator":false,"karma":8490,"avatar_url":"/avatars/caius-100.png","invited_by_user":"lauris","github_username":"caius","twitter_username":"Caius"},"tags":["ask","programming"]},{"short_id":"exun2m","short_id_url":"https://lobste.rs/s/exun2m","created_at":"2023-01-20T05:13:57.000-06:00","title":"A curated list of questions to work on a client's infrastructure / migrate applications to the cloud","url":"https://github.com/dyrector-io/awesome-infrastructure-questions","score":2,"flags":0,"comment_count":1,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/exun2m/curated_list_questions_work_on_client_s","submitter_user":{"username":"polaroi8d","created_at":"2023-01-11T01:18:33.000-06:00","is_admin":false,"about":"builder / product engineer / people addict ","is_moderator":false,"karma":18,"avatar_url":"/avatars/polaroi8d-100.png","invited_by_user":"apc","github_username":"polaroi8d"},"tags":["devops"]},{"short_id":"u6nz4f","short_id_url":"https://lobste.rs/s/u6nz4f","created_at":"2023-01-20T01:48:37.000-06:00","title":"Debugging a Crash in OpenRCT2","url":"http://voidstar.tech/rct_crash/","score":13,"flags":0,"comment_count":2,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/u6nz4f/debugging_crash_openrct2","submitter_user":{"username":"raymii","created_at":"2013-11-20T11:58:43.000-06:00","is_admin":false,"about":"üêã\r\nhttps://raymii.org","is_moderator":false,"karma":19293,"avatar_url":"/avatars/raymii-100.png","invited_by_user":"journeysquid"},"tags":["games"]},{"short_id":"igjz04","short_id_url":"https://lobste.rs/s/igjz04","created_at":"2023-01-19T20:45:14.000-06:00","title":"polyfill-data: Adds the Ruby 3.2 Data class to lower Ruby versions","url":"https://github.com/saturnflyer/polyfill-data","score":1,"flags":0,"comment_count":0,"description":"","description_plain":"","comments_url":"https://lobste.rs/s/igjz04/polyfill_data_adds_ruby_3_2_data_class","submitter_user":{"username":"saturnflyer","created_at":"2013-10-28T11:58:44.000-05:00","is_admin":false,"about":"I hack mostly in Ruby and authored Clean Ruby http://clean-ruby.com, Ruby DSL Handbook http://clean-ruby.com/dsl, and the Ruby Metaprogramming MasterClass http://master-class.saturnflyer.com","is_moderator":false,"karma":82,"avatar_url":"/avatars/saturnflyer-100.png","invited_by_user":"SeanTAllen"},"tags":["ruby"]}]